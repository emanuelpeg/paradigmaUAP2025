module Main exposing (..)

import Html exposing (Html, text)


main : Html msg
main =
    text "Hello, Elm!"


add : Int -> Int -> Int
add a b =
    a + b


multiply : Int -> Int -> Int
multiply a b =
    a * b


-- Ejercicio 1: Función Potencia
-- Calcula `a` elevado a la `b` de forma recursiva.
power : Int -> Int -> Int
power a b =
    -- Caso base: si el exponente es negativo, no está definido para enteros, devolvemos 0.
    if b < 0 then
        0

    -- Caso base: cualquier número elevado a 0 es 1.
    else if b == 0 then
        1

    -- Paso recursivo: a^b = a * a^(b-1)
    else
        a * power a (b - 1)


-- Ejercicio 2: Factorial
-- Calcula el factorial de un número `n`.
factorial : Int -> Int
factorial n =
    -- Por convención, el factorial de números negativos no es estándar, devolvemos 1.
    if n < 0 then
        1

    -- Caso base: el factorial de 0 y 1 es 1.
    else if n <= 1 then
        1

    -- Paso recursivo: n! = n * (n-1)!
    else
        n * factorial (n - 1)


-- Ejercicio 3: Fibonacci
fibonacciExponential : Int -> Int
fibonacciExponential n =
    -- Los primeros dos números de la secuencia.
    if n <= 0 then
        0

    else if n == 1 then
        1

    -- Paso recursivo: cada número es la suma de los dos anteriores.
    else
        fibonacciExponential (n - 1) + fibonacciExponential (n - 2)


fibonacciLinear : Int -> Int
fibonacciLinear n =
    if n <= 0 then
        0

    -- Usamos una función auxiliar para llevar el estado.
    else
        fibonacciHelper n 0 1


-- Función auxiliar para el Fibonacci lineal.
-- `counter` es el número de pasos que nos quedan.
-- `current` y `next` son los dos últimos números de la secuencia calculados.
fibonacciHelper : Int -> Int -> Int -> Int
fibonacciHelper counter current next =
    -- Cuando el contador llega a 1, `next` tiene el resultado.
    if counter == 1 then
        next

    -- En cada paso, avanzamos en la secuencia.
    else
        fibonacciHelper (counter - 1) next (current + next)


-- Ejercicio 4: Triángulo de Pascal
-- Calcula el valor en una posición (x, y) del triángulo de Pascal.
pascalTriangle : Int -> Int -> Int
pascalTriangle x y =
    -- Las posiciones fuera del triángulo valen 0.
    if x < 0 || x > y then
        0

    -- Los bordes del triángulo siempre valen 1.
    else if x == 0 || x == y then
        1

    -- Cualquier otro valor es la suma de los dos que tiene encima.
    else
        pascalTriangle (x - 1) (y - 1) + pascalTriangle x (y - 1)


-- Ejercicio 5: Máximo Común Divisor
gcd : Int -> Int -> Int
gcd a b =
    -- Caso base: cuando `b` es 0, el MCD es `a`.
    if b == 0 then
        abs a

    -- Paso recursivo: el MCD de `a` y `b` es el mismo que el de `b` y el resto de `a/b`.
    else
        gcd b (remainderBy b a)


-- Ejercicio 6: Contar Dígitos
-- Cuenta cuántos dígitos tiene un número entero.
countDigits : Int -> Int
countDigits n =
    let
        -- Trabajamos con el valor absoluto para ignorar el signo.
        num =
            abs n
    in
    -- Caso base: si el número es menor que 10, tiene un solo dígito.
    if num < 10 then
        1

    -- Paso recursivo: es 1 más los dígitos del número sin su última cifra.
    else
        1 + countDigits (num // 10)


-- Ejercicio 7: Suma de Dígitos
-- Suma todos los dígitos de un número.
sumDigits : Int -> Int
sumDigits n =
    let
        -- De nuevo, usamos el valor absoluto.
        num =
            abs n
    in
    -- Caso base: si tiene un solo dígito, la suma es el propio número.
    if num < 10 then
        num

    -- Paso recursivo: es el último dígito más la suma del resto.
    else
        (remainderBy 10 num) + sumDigits (num // 10)


-- Ejercicio 8: Verificar Palíndromo
-- Comprueba si un número se lee igual de izquierda a derecha que de derecha a izquierda.
isPalindrome : Int -> Bool
isPalindrome n =
    let
        -- Nos aseguramos de que sea positivo.
        num =
            abs n
    in
    -- Un número es palíndromo si es igual a su reverso.
    num == reverseNumber num


-- Función principal para invertir un número.
reverseNumber : Int -> Int
reverseNumber n =
    -- Llama a la función auxiliar con un acumulador inicial de 0.
    reverseHelper (abs n) 0


-- Invierte el número `num` usando un acumulador `acc`.
reverseHelper : Int -> Int -> Int
reverseHelper num acc =
    -- Caso base: si no quedan dígitos, el acumulador tiene el resultado.
    if num == 0 then
        acc

    else
        let
            -- Obtenemos el último dígito.
            lastDigit =
                remainderBy 10 num

            -- Le quitamos el último dígito al número.
            remaining =
                num // 10
        in
        -- Movemos los dígitos del acumulador a la izquierda y añadimos el nuevo.
        reverseHelper remaining (acc * 10 + lastDigit)
